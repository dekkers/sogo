From: Jeroen Dekkers <jeroen@dekkers.ch>
Date: Sat, 30 Jun 2012 01:55:46 +0200
Subject: Add support for GnuTLS

---
 SoObjects/SOGo/GNUmakefile.preamble          |   10 +-
 SoObjects/SOGo/NSData+Crypto.m               |  216 +++++++++++++++++++++++++-
 Tests/Unit/GNUmakefile                       |    2 +
 Tests/Unit/TestNSData+Crypto.m               |  101 ++++++++++++
 Tests/Unit/TestNSString+Crypto.m             |   64 ++++++++
 UI/MailPartViewers/GNUmakefile.preamble      |    4 +
 UI/MailPartViewers/UIxMailPartSignedViewer.m |   14 ++
 configure                                    |   36 +++--
 maintenance/dummytool.c                      |    7 +
 9 files changed, 441 insertions(+), 13 deletions(-)
 create mode 100644 Tests/Unit/TestNSData+Crypto.m
 create mode 100644 Tests/Unit/TestNSString+Crypto.m
 create mode 100644 UI/MailPartViewers/GNUmakefile.preamble
 create mode 100644 maintenance/dummytool.c

diff --git a/SoObjects/SOGo/GNUmakefile.preamble b/SoObjects/SOGo/GNUmakefile.preamble
index 9334ba4..da6986f 100644
--- a/SoObjects/SOGo/GNUmakefile.preamble
+++ b/SoObjects/SOGo/GNUmakefile.preamble
@@ -24,7 +24,15 @@ SOGo_LIBRARIES_DEPEND_UPON += \
 	-lNGStreams -lNGExtensions -lEOControl \
 	-lDOM -lSaxObjC \
 	-lNGLdap -lSBJson \
-        -lGDLContentStore -lcrypto -lgnustep-base -lobjc -ldl
+        -lGDLContentStore -lgnustep-base -lobjc -ldl
+
+ifeq ($(HAS_LIBRARY_gnutls),yes)
+ADDITIONAL_CPPFLAGS += -DHAVE_GNUTLS=1
+SOGo_LIBRARIES_DEPEND_UPON += -lgnutls
+else
+ADDITIONAL_CPPFLAGS += -DHAVE_OPENSSL=1
+SOGo_LIBRARIES_DEPEND_UPON += -lcrypto
+endif
 
 ifeq ($(findstring openbsd, $(GNUSTEP_HOST_OS)), openbsd)
 SOGo_LIBRARIES_DEPEND_UPON += -lcrypto
diff --git a/SoObjects/SOGo/NSData+Crypto.m b/SoObjects/SOGo/NSData+Crypto.m
index c50ad96..e42ee3e 100644
--- a/SoObjects/SOGo/NSData+Crypto.m
+++ b/SoObjects/SOGo/NSData+Crypto.m
@@ -2,6 +2,7 @@
  *
  * Copyright (C) 2012 Nicolas Höft
  * Copyright (C) 2012 Inverse inc.
+ * Copyright (C) 2012 Jeroen Dekkers
  *
  * Author: Nicolas Höft
  *         Inverse inc.
@@ -33,15 +34,30 @@
 
 #define _XOPEN_SOURCE 1
 #include <unistd.h>
+
+#ifdef HAVE_GNUTLS
+#include <stdint.h>
+#include <gnutls/gnutls.h>
+#include <gnutls/crypto.h>
+#define MD5_DIGEST_LENGTH 16
+#define SHA_DIGEST_LENGTH 20
+#define SHA256_DIGEST_LENGTH 32
+#define SHA512_DIGEST_LENGTH 64
+#else
 #include <openssl/evp.h>
 #include <openssl/md5.h>
 #include <openssl/sha.h>
+#endif
 
 #import <Foundation/NSArray.h>
 #import <NGExtensions/NGBase64Coding.h>
 #import "NSData+Crypto.h"
 
-unsigned charTo4Bits(char c);
+static unsigned charTo4Bits(char c);
+#ifdef HAVE_GNUTLS
+static BOOL check_gnutls_init();
+static void _nettle_md5_compress(uint32_t *digest, const uint8_t *input);
+#endif
 
 
 @implementation NSData (SOGoCryptoExtension)
@@ -228,7 +244,13 @@ unsigned charTo4Bits(char c);
   unsigned char md5[MD5_DIGEST_LENGTH];
   memset(md5, 0, MD5_DIGEST_LENGTH);
 
+#ifdef HAVE_GNUTLS
+  if (!check_gnutls_init())
+    return nil;
+  gnutls_hash_fast (GNUTLS_DIG_MD5, [self bytes], [self length], md5);
+#else
   MD5([self bytes], [self length], md5);
+#endif
 
   return [NSData dataWithBytes: md5  length: MD5_DIGEST_LENGTH];
 }
@@ -247,8 +269,12 @@ unsigned charTo4Bits(char c);
  */
 - (NSData *) asCramMD5
 {
-  
+#ifdef HAVE_GNUTLS
+  const uint32_t init_digest[4] = {0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476};
+  uint32_t digest[4];
+#else
   MD5_CTX ctx;
+#endif
   unsigned char inner[64];
   unsigned char outer[64];
   unsigned char result[32];
@@ -286,6 +312,27 @@ unsigned charTo4Bits(char c);
     *p = (c) >> 24 & 0xff; p++; \
 }
 
+#ifdef HAVE_GNUTLS
+  // generate first set of context bytes from outer data
+  memcpy(digest, init_digest, sizeof(digest));
+  _nettle_md5_compress(digest, outer);
+
+  r = result;
+  // convert this to correct binary data according to RFC 1321
+  CDPUT(r, digest[0]);
+  CDPUT(r, digest[1]);
+  CDPUT(r, digest[2]);
+  CDPUT(r, digest[3]);
+
+  // second set with inner data is appended to result string
+  memcpy(digest, init_digest, sizeof(digest));
+  _nettle_md5_compress(digest, inner);
+  // convert this to correct binary data
+  CDPUT(r, digest[0]);
+  CDPUT(r, digest[1]);
+  CDPUT(r, digest[2]);
+  CDPUT(r, digest[3]);
+#else
   // generate first set of context bytes from outer data
   MD5_Init(&ctx);
   MD5_Transform(&ctx, outer);
@@ -304,6 +351,7 @@ unsigned charTo4Bits(char c);
   CDPUT(r, ctx.B);
   CDPUT(r, ctx.C);
   CDPUT(r, ctx.D);
+#endif
 
   return [NSData dataWithBytes: result length: 32];
 }
@@ -318,7 +366,13 @@ unsigned charTo4Bits(char c);
   unsigned char sha[SHA_DIGEST_LENGTH];
   memset(sha, 0, SHA_DIGEST_LENGTH);
 
+#ifdef HAVE_GNUTLS
+  if (!check_gnutls_init())
+    return nil;
+  gnutls_hash_fast (GNUTLS_DIG_SHA1, [self bytes], [self length], sha);
+#else
   SHA1([self bytes], [self length], sha);
+#endif
 
   return [NSData dataWithBytes: sha  length: SHA_DIGEST_LENGTH];
 }
@@ -333,7 +387,13 @@ unsigned charTo4Bits(char c);
   unsigned char sha[SHA256_DIGEST_LENGTH];
   memset(sha, 0, SHA256_DIGEST_LENGTH);
 
+#ifdef HAVE_GNUTLS
+  if (!check_gnutls_init())
+    return nil;
+  gnutls_hash_fast (GNUTLS_DIG_SHA256, [self bytes], [self length], sha);
+#else
   SHA256([self bytes], [self length], sha);
+#endif
 
   return [NSData dataWithBytes: sha  length: SHA256_DIGEST_LENGTH];
 }
@@ -348,7 +408,13 @@ unsigned charTo4Bits(char c);
   unsigned char sha[SHA512_DIGEST_LENGTH];
   memset(sha, 0, SHA512_DIGEST_LENGTH);
 
+#ifdef HAVE_GNUTLS
+  if (!check_gnutls_init())
+    return nil;
+  gnutls_hash_fast (GNUTLS_DIG_SHA512, [self bytes], [self length], sha);
+#else
   SHA512([self bytes], [self length], sha);
+#endif
 
   return [NSData dataWithBytes: sha  length: SHA512_DIGEST_LENGTH];
 }
@@ -597,7 +663,7 @@ unsigned charTo4Bits(char c);
 
 @end
 
-unsigned charTo4Bits(char c)
+static unsigned charTo4Bits(char c)
 {
   unsigned bits = 0;
   if (c > '/' && c < ':')
@@ -618,3 +684,147 @@ unsigned charTo4Bits(char c)
     }
   return bits;
 }
+
+#ifdef HAVE_GNUTLS
+static BOOL didGlobalInit = NO;
+
+static BOOL check_gnutls_init() {
+  if (!didGlobalInit) {
+    /* Global system initialization*/
+    if (gnutls_global_init()) {
+      return NO;
+    }
+
+    didGlobalInit = YES;
+  }
+
+  return YES;
+}
+
+/* nettle, low-level cryptographics library
+ *
+ * Copyright (C) 2001, 2005 Niels Möller
+ *
+ * The nettle library is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or (at your
+ * option) any later version.
+ *
+ * The nettle library is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
+ * License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with the nettle library; see the file COPYING.LIB.  If not, write to
+ * the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
+ * MA 02111-1307, USA.
+ */
+
+/* Based on public domain code hacked by Colin Plumb, Andrew Kuchling, and
+ * Niels Möller. */
+
+#define LE_READ_UINT32(p)			\
+(  (((uint32_t) (p)[3]) << 24)			\
+ | (((uint32_t) (p)[2]) << 16)			\
+ | (((uint32_t) (p)[1]) << 8)			\
+ |  ((uint32_t) (p)[0]))
+
+/* MD5 functions */
+#define F1(x, y, z) ((z) ^ ((x) & ((y) ^ (z))))
+#define F2(x, y, z) F1((z), (x), (y))
+#define F3(x, y, z) ((x) ^ (y) ^ (z))
+#define F4(x, y, z) ((y) ^ ((x) | ~(z)))
+
+#define ROUND(f, w, x, y, z, data, s) \
+( w += f(x, y, z) + data,  w = w<<s | w>>(32-s),  w += x )
+
+static void
+_nettle_md5_compress(uint32_t *digest, const uint8_t *input)
+{
+  uint32_t data[MD5_DIGEST_LENGTH];
+  uint32_t a, b, c, d;
+  unsigned i;
+
+  for (i = 0; i < MD5_DIGEST_LENGTH; i++, input += 4)
+    data[i] = LE_READ_UINT32(input);
+
+  a = digest[0];
+  b = digest[1];
+  c = digest[2];
+  d = digest[3];
+
+  ROUND(F1, a, b, c, d, data[ 0] + 0xd76aa478, 7);
+  ROUND(F1, d, a, b, c, data[ 1] + 0xe8c7b756, 12);
+  ROUND(F1, c, d, a, b, data[ 2] + 0x242070db, 17);
+  ROUND(F1, b, c, d, a, data[ 3] + 0xc1bdceee, 22);
+  ROUND(F1, a, b, c, d, data[ 4] + 0xf57c0faf, 7);
+  ROUND(F1, d, a, b, c, data[ 5] + 0x4787c62a, 12);
+  ROUND(F1, c, d, a, b, data[ 6] + 0xa8304613, 17);
+  ROUND(F1, b, c, d, a, data[ 7] + 0xfd469501, 22);
+  ROUND(F1, a, b, c, d, data[ 8] + 0x698098d8, 7);
+  ROUND(F1, d, a, b, c, data[ 9] + 0x8b44f7af, 12);
+  ROUND(F1, c, d, a, b, data[10] + 0xffff5bb1, 17);
+  ROUND(F1, b, c, d, a, data[11] + 0x895cd7be, 22);
+  ROUND(F1, a, b, c, d, data[12] + 0x6b901122, 7);
+  ROUND(F1, d, a, b, c, data[13] + 0xfd987193, 12);
+  ROUND(F1, c, d, a, b, data[14] + 0xa679438e, 17);
+  ROUND(F1, b, c, d, a, data[15] + 0x49b40821, 22);
+
+  ROUND(F2, a, b, c, d, data[ 1] + 0xf61e2562, 5);
+  ROUND(F2, d, a, b, c, data[ 6] + 0xc040b340, 9);
+  ROUND(F2, c, d, a, b, data[11] + 0x265e5a51, 14);
+  ROUND(F2, b, c, d, a, data[ 0] + 0xe9b6c7aa, 20);
+  ROUND(F2, a, b, c, d, data[ 5] + 0xd62f105d, 5);
+  ROUND(F2, d, a, b, c, data[10] + 0x02441453, 9);
+  ROUND(F2, c, d, a, b, data[15] + 0xd8a1e681, 14);
+  ROUND(F2, b, c, d, a, data[ 4] + 0xe7d3fbc8, 20);
+  ROUND(F2, a, b, c, d, data[ 9] + 0x21e1cde6, 5);
+  ROUND(F2, d, a, b, c, data[14] + 0xc33707d6, 9);
+  ROUND(F2, c, d, a, b, data[ 3] + 0xf4d50d87, 14);
+  ROUND(F2, b, c, d, a, data[ 8] + 0x455a14ed, 20);
+  ROUND(F2, a, b, c, d, data[13] + 0xa9e3e905, 5);
+  ROUND(F2, d, a, b, c, data[ 2] + 0xfcefa3f8, 9);
+  ROUND(F2, c, d, a, b, data[ 7] + 0x676f02d9, 14);
+  ROUND(F2, b, c, d, a, data[12] + 0x8d2a4c8a, 20);
+
+  ROUND(F3, a, b, c, d, data[ 5] + 0xfffa3942, 4);
+  ROUND(F3, d, a, b, c, data[ 8] + 0x8771f681, 11);
+  ROUND(F3, c, d, a, b, data[11] + 0x6d9d6122, 16);
+  ROUND(F3, b, c, d, a, data[14] + 0xfde5380c, 23);
+  ROUND(F3, a, b, c, d, data[ 1] + 0xa4beea44, 4);
+  ROUND(F3, d, a, b, c, data[ 4] + 0x4bdecfa9, 11);
+  ROUND(F3, c, d, a, b, data[ 7] + 0xf6bb4b60, 16);
+  ROUND(F3, b, c, d, a, data[10] + 0xbebfbc70, 23);
+  ROUND(F3, a, b, c, d, data[13] + 0x289b7ec6, 4);
+  ROUND(F3, d, a, b, c, data[ 0] + 0xeaa127fa, 11);
+  ROUND(F3, c, d, a, b, data[ 3] + 0xd4ef3085, 16);
+  ROUND(F3, b, c, d, a, data[ 6] + 0x04881d05, 23);
+  ROUND(F3, a, b, c, d, data[ 9] + 0xd9d4d039, 4);
+  ROUND(F3, d, a, b, c, data[12] + 0xe6db99e5, 11);
+  ROUND(F3, c, d, a, b, data[15] + 0x1fa27cf8, 16);
+  ROUND(F3, b, c, d, a, data[ 2] + 0xc4ac5665, 23);
+
+  ROUND(F4, a, b, c, d, data[ 0] + 0xf4292244, 6);
+  ROUND(F4, d, a, b, c, data[ 7] + 0x432aff97, 10);
+  ROUND(F4, c, d, a, b, data[14] + 0xab9423a7, 15);
+  ROUND(F4, b, c, d, a, data[ 5] + 0xfc93a039, 21);
+  ROUND(F4, a, b, c, d, data[12] + 0x655b59c3, 6);
+  ROUND(F4, d, a, b, c, data[ 3] + 0x8f0ccc92, 10);
+  ROUND(F4, c, d, a, b, data[10] + 0xffeff47d, 15);
+  ROUND(F4, b, c, d, a, data[ 1] + 0x85845dd1, 21);
+  ROUND(F4, a, b, c, d, data[ 8] + 0x6fa87e4f, 6);
+  ROUND(F4, d, a, b, c, data[15] + 0xfe2ce6e0, 10);
+  ROUND(F4, c, d, a, b, data[ 6] + 0xa3014314, 15);
+  ROUND(F4, b, c, d, a, data[13] + 0x4e0811a1, 21);
+  ROUND(F4, a, b, c, d, data[ 4] + 0xf7537e82, 6);
+  ROUND(F4, d, a, b, c, data[11] + 0xbd3af235, 10);
+  ROUND(F4, c, d, a, b, data[ 2] + 0x2ad7d2bb, 15);
+  ROUND(F4, b, c, d, a, data[ 9] + 0xeb86d391, 21);
+
+  digest[0] += a;
+  digest[1] += b;
+  digest[2] += c;
+  digest[3] += d;
+}
+#endif
diff --git a/Tests/Unit/GNUmakefile b/Tests/Unit/GNUmakefile
index 6c54a19..c95bd73 100644
--- a/Tests/Unit/GNUmakefile
+++ b/Tests/Unit/GNUmakefile
@@ -22,6 +22,8 @@ $(TEST_TOOL)_OBJC_FILES += \
 	TestSBJsonParser.m \
 	\
 	TestNGMimeAddressHeaderFieldGenerator.m \
+	TestNSData+Crypto.m \
+	TestNSString+Crypto.m \
 	TestNSString+URLEscaping.m \
 	TestNSString+Utilities.m
 
diff --git a/Tests/Unit/TestNSData+Crypto.m b/Tests/Unit/TestNSData+Crypto.m
new file mode 100644
index 0000000..6039a9a
--- /dev/null
+++ b/Tests/Unit/TestNSData+Crypto.m
@@ -0,0 +1,101 @@
+/* TestNSString+MD5SHA1.m - this file is part of SOGo
+ *
+ * Copyright (C) 2011, 2012 Jeroen Dekkers
+ *
+ * Author: Jeroen Dekkers <jeroen@dekkers.ch>
+ *
+ * This file is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This file is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; see the file COPYING.  If not, write to
+ * the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#import <Foundation/NSString.h>
+#import <Foundation/NSData.h>
+#import "SOGo/NSData+Crypto.h"
+
+#import "SOGoTest.h"
+
+@interface TestNSString_plus_Crypto : SOGoTest
+@end
+
+@implementation TestNSString_plus_Crypto
+
+- (void) test_stringCrypto
+{
+  const char *inStrings[] = { "SOGoSOGoSOGoSOGo", "éléphant", "2š", NULL };
+  const char **inString;
+  NSString *MD5Strings[] = { @"d3e8072c49511f099d254cc740c7e12a", @"bc6a1535589d6c3cf7999ac37018c11e", @"886ae9b58817fb8a63902feefcd18812" };
+  NSString *CramMD5Strings[] = { @"807cf6d4995482060b2e9b1bc3fe1507a42c51dc97d86302b460f7878f0551e2", @"72a6cb4f15711350c3e3d83a9cb631eb0dcc06e56776bed15766e65e0fdb7694",
+				 @"14bef22dd8c749f6ff3ebbfa51261291e3c1dc42e3dc13ae3771d01de8e53ccd" };
+  NSString *SHA1Strings[] = { @"b7d891e0f3b42898fa66627b5cfa3d80501bae46", @"99a02f8802f8ea7e3ad91c4cc4d3ef5a7257c88f", @"32b89f3a9e6078db554cdd39f8571c09de7e8b21" };
+  NSString *SHA256Strings[] = { @"3d5c087342ad6208e7f4bc353c5e739dcd14137f6e4159779347fea2e7f562bf", @"c941ae685f62cbe7bb47d0791af7154788fd9e873e5c57fd2449d1454ed5b16f",
+				@"f89a911feceaf3d9c28f4e431edff50c265933102476b1814f83704a7bc46890" };
+  NSString *SHA512Strings[] = { @"e003b24f05d1b007e5f5a87f726668cb47301d1366cd8d8632646483b1e570335feae34e1e88213a53bab78a876eb805317f290fbf71a1ac79d1275d4a24dee7",
+				@"c6f2bb64ee795ad613b4521cd65618d2a036ae6423513a22eddc1bb8a88e5486add61fc1f3a0fc592ce9c24598a23b4ec854f96ccdf73808f701dced2a9b0d64",
+				@"49d72f3626d6a56483b3cb4a6da336c423825dbe92d5e225ea2fd69fca1b28d8bceb1544b85847c4fac5c5e0c378b4384f2ac7c230c73dd389061d1b0198c14c" };
+  NSString **MD5String;
+  NSString **CramMD5String;
+  NSString **SHA1String;
+  NSString **SHA256String;
+  NSString **SHA512String;
+  NSData *result;
+  NSString *error;
+
+  inString = inStrings;
+  CramMD5String = CramMD5Strings;
+  MD5String = MD5Strings;
+  SHA1String = SHA1Strings;
+  SHA256String = SHA256Strings;
+  SHA512String = SHA512Strings;
+  while (*inString)
+    {
+      result = [[[NSString stringWithUTF8String: *inString] dataUsingEncoding: NSUTF8StringEncoding] asMD5];
+      error = [NSString stringWithFormat:
+                          @"string '%s' wrong MD5: '%@' (expected '%@')",
+                        *inString, result, *MD5String];
+      testWithMessage([[NSData encodeDataAsHexString: result] isEqualToString: *MD5String], error);
+
+      result = [[[NSString stringWithUTF8String: *inString] dataUsingEncoding: NSUTF8StringEncoding] asCramMD5];
+      error = [NSString stringWithFormat:
+                          @"string '%s' wrong CramMD5: '%@' (expected '%@')",
+                        *inString, result, *CramMD5String];
+      testWithMessage([[NSData encodeDataAsHexString: result] isEqualToString: *CramMD5String], error);
+
+      result = [[[NSString stringWithUTF8String: *inString] dataUsingEncoding: NSUTF8StringEncoding] asSHA1];
+      error = [NSString stringWithFormat:
+                          @"string '%s' wrong SHA1: '%@' (expected '%@')",
+                        *inString, result, *SHA1String];
+      testWithMessage([[NSData encodeDataAsHexString: result] isEqualToString: *SHA1String], error);
+
+      result = [[[NSString stringWithUTF8String: *inString] dataUsingEncoding: NSUTF8StringEncoding] asSHA256];
+      error = [NSString stringWithFormat:
+                          @"string '%s' wrong SHA256: '%@' (expected '%@')",
+                        *inString, result, *SHA256String];
+      testWithMessage([[NSData encodeDataAsHexString: result] isEqualToString: *SHA256String], error);
+
+      result = [[[NSString stringWithUTF8String: *inString] dataUsingEncoding: NSUTF8StringEncoding] asSHA512];
+      error = [NSString stringWithFormat:
+                          @"string '%s' wrong SHA512: '%@' (expected '%@')",
+                        *inString, result, *SHA512String];
+      testWithMessage([[NSData encodeDataAsHexString: result] isEqualToString: *SHA512String], error);
+      inString++;
+      MD5String++;
+      CramMD5String++;
+      SHA1String++;
+      SHA256String++;
+      SHA512String++;
+    }
+}
+
+@end
diff --git a/Tests/Unit/TestNSString+Crypto.m b/Tests/Unit/TestNSString+Crypto.m
new file mode 100644
index 0000000..f0a08c5
--- /dev/null
+++ b/Tests/Unit/TestNSString+Crypto.m
@@ -0,0 +1,64 @@
+/* TestNSString+MD5SHA1.m - this file is part of SOGo
+ *
+ * Copyright (C) 2011, 2012 Jeroen Dekkers
+ *
+ * Author: Jeroen Dekkers <jeroen@dekkers.ch>
+ *
+ * This file is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This file is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; see the file COPYING.  If not, write to
+ * the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#import <Foundation/NSString.h>
+#import "SOGo/NSString+Crypto.h"
+
+#import "SOGoTest.h"
+
+@interface TestNSData_plus_Crypto : SOGoTest
+@end
+
+@implementation TestNSData_plus_Crypto
+
+- (void) test_dataCrypto
+{
+  const char *inStrings[] = { "SOGoSOGoSOGoSOGo", "éléphant", "2š", NULL };
+  const char **inString;
+  NSString *MD5Strings[] = { @"d3e8072c49511f099d254cc740c7e12a", @"bc6a1535589d6c3cf7999ac37018c11e", @"886ae9b58817fb8a63902feefcd18812" };
+  NSString *SHA1Strings[] = { @"b7d891e0f3b42898fa66627b5cfa3d80501bae46", @"99a02f8802f8ea7e3ad91c4cc4d3ef5a7257c88f", @"32b89f3a9e6078db554cdd39f8571c09de7e8b21" };
+  NSString **MD5String;
+  NSString **SHA1String;
+  NSString *result, *error;
+
+  inString = inStrings;
+  MD5String = MD5Strings;
+  SHA1String = SHA1Strings;
+  while (*inString)
+    {
+      result = [[NSString stringWithUTF8String: *inString] asMD5String];
+      error = [NSString stringWithFormat:
+                          @"string '%s' wrong MD5: '%@' (expected '%@')",
+                        *inString, result, *MD5String];
+      testWithMessage([result isEqualToString: *MD5String], error);
+      result = [[NSString stringWithUTF8String: *inString] asSHA1String];
+      error = [NSString stringWithFormat:
+                          @"string '%s' wrong SHA1: '%@' (expected '%@')",
+                        *inString, result, *SHA1String];
+      testWithMessage([result isEqualToString: *SHA1String], error);
+      inString++;
+      MD5String++;
+      SHA1String++;
+    }
+}
+
+@end
diff --git a/UI/MailPartViewers/GNUmakefile.preamble b/UI/MailPartViewers/GNUmakefile.preamble
new file mode 100644
index 0000000..545cdf4
--- /dev/null
+++ b/UI/MailPartViewers/GNUmakefile.preamble
@@ -0,0 +1,4 @@
+ifeq ($(HAS_LIBRARY_ssl),yes)
+ADDITIONAL_CPPFLAGS += -DHAVE_OPENSSL=1
+BUNDLE_LIBS += -lcrypto
+endif
diff --git a/UI/MailPartViewers/UIxMailPartSignedViewer.m b/UI/MailPartViewers/UIxMailPartSignedViewer.m
index 77aad8b..e707c4a 100644
--- a/UI/MailPartViewers/UIxMailPartSignedViewer.m
+++ b/UI/MailPartViewers/UIxMailPartSignedViewer.m
@@ -22,10 +22,12 @@
  */
 
 #include <stdio.h>
+#ifdef HAVE_OPENSSL
 #include <openssl/bio.h>
 #include <openssl/err.h>
 #include <openssl/pkcs7.h>
 #include <openssl/x509.h>
+#endif
 
 #import <Foundation/NSArray.h>
 #import <NGMime/NGPart.h>
@@ -35,6 +37,7 @@
 
 @implementation UIxMailPartSignedViewer : UIxMailPartMixedViewer
 
+#ifdef HAVE_OPENSSL
 - (X509_STORE *) _setupVerify
 {
   X509_STORE *store;
@@ -185,5 +188,16 @@
 
   return validationMessage;
 }
+#else
+- (BOOL) validSignature
+{
+  return NO;
+}
+
+- (NSString *) validationMessage
+{
+  return @"Signature verification is not implemented when using GnuTLS";
+}
+#endif
 
 @end
diff --git a/configure b/configure
index d2b2317..ad3bff7 100755
--- a/configure
+++ b/configure
@@ -303,27 +303,39 @@ genConfigMake() {
 }
 
 checkLinking() {
+  # library-name => $1, type => $2
   local oldpwd=$PWD
   local tmpdir=".configure-test-$$"
   
   mkdir $tmpdir
   cd $tmpdir
-  cp ../maintenance/dummytool.m .
+  cp ../maintenance/dummytool.c .
   
+  OLDLIBS=$LIBS
+  for LIB in $1;do
+    LIBS="$LIBS -l${LIB}"
+  done
+
   tmpmake="GNUmakefile"
-  echo  >$tmpmake "include ../config.make"
+  echo  >$tmpmake "-include ../config.make"
   echo >>$tmpmake "include \$(GNUSTEP_MAKEFILES)/common.make"
-  echo >>$tmpmake "TOOL_NAME           := linktest"
-  echo >>$tmpmake "linktest_OBJC_FILES := dummytool.m"
-  echo >>$tmpmake "linktest_TOOL_LIBS  += -l$1"
+  echo >>$tmpmake "CTOOL_NAME           := linktest"
+  echo >>$tmpmake "linktest_C_FILES := dummytool.c"
+  echo >>$tmpmake "ifeq (\$(findstring openbsd, \$(GNUSTEP_HOST_OS)), openbsd)"
+  echo >>$tmpmake "linktest_TOOL_LIBS  += $LIBS -liconv"
+  echo >>$tmpmake "else"
+  echo >>$tmpmake "linktest_TOOL_LIBS  += $LIBS"
+  echo >>$tmpmake "endif"
+  echo >>$tmpmake "SYSTEM_LIB_DIR += \$(CONFIGURE_SYSTEM_LIB_DIR)"
   echo >>$tmpmake "SYSTEM_LIB_DIR      += ${LINK_SYSLIBDIRS}"
-  echo >>$tmpmake "include \$(GNUSTEP_MAKEFILES)/tool.make"
+  echo >>$tmpmake "include \$(GNUSTEP_MAKEFILES)/ctool.make"
   
   $MAKE -s messages=yes -f $tmpmake linktest >out.log 2>err.log
   LINK_RESULT=$?
 
   if test $LINK_RESULT = 0; then
     echo "$2 library found: $1"
+    cfgwrite "HAS_LIBRARY_$1=yes"
   else
     if test "x$2" = "xrequired"; then
       echo "failed to link $2 library: $1"
@@ -331,16 +343,22 @@ checkLinking() {
       exit 1
     else
       echo "failed to link $2 library: $1"
+      cfgwrite "HAS_LIBRARY_$1=no"
+      LIBS=$OLDLIBS
     fi
   fi
   
   cd $oldpwd
   rm -rf $tmpdir
+
+  return $LINK_RESULT
 }
 
 checkDependencies() {
-  checkLinking "SaxObjC" required;
-  checkLinking "NGLdap"  required;
+  checkLinking "gnutls"      optional;
+  if test $? != 0; then
+      checkLinking "ssl"      required;
+  fi
 }
 
 runIt() {
@@ -363,7 +381,7 @@ runIt() {
     fi
   else
     genConfigMake;
-    #checkDependencies;
+    checkDependencies;
     
     if test -x $NGSTREAMS_DIR/configure; then
       if test $ARG_BEQUIET != 1; then
diff --git a/maintenance/dummytool.c b/maintenance/dummytool.c
new file mode 100644
index 0000000..0566948
--- /dev/null
+++ b/maintenance/dummytool.c
@@ -0,0 +1,7 @@
+// Note: do not remove, used by ../configure
+
+#include <stdio.h>
+
+int main(int argc, char **argv) {
+  return 0;
+}
